{"ast":null,"code":"import{CreateLinkEvent}from'../nitro';import{cancelRoomObjectPlacement,getPlacingItemId}from'./InventoryUtilities';import{UnseenItemCategory}from'./unseen';export const getAllPetIds=petItems=>petItems.map(item=>item.petData.id);export const addSinglePetItem=function(petData,set){let unseen=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;const petItem={petData};if(unseen){//petItem.isUnseen = true;\nset.unshift(petItem);}else{set.push(petItem);}return petItem;};export const removePetItemById=(id,set)=>{let index=0;while(index<set.length){const petItem=set[index];if(petItem&&petItem.petData.id===id){if(getPlacingItemId()===petItem.petData.id){cancelRoomObjectPlacement();CreateLinkEvent('inventory/open');}set.splice(index,1);return petItem;}index++;}return null;};export const processPetFragment=(set,fragment,isUnseen)=>{const existingIds=getAllPetIds(set);const addedIds=[];const removedIds=[];for(const key of fragment.keys())existingIds.indexOf(key)===-1&&addedIds.push(key);for(const itemId of existingIds)!fragment.get(itemId)&&removedIds.push(itemId);const emptyExistingSet=existingIds.length===0;for(const id of removedIds)removePetItemById(id,set);for(const id of addedIds){const parser=fragment.get(id);if(!parser)continue;addSinglePetItem(parser,set,isUnseen(UnseenItemCategory.PET,parser.id));}return set;};export const mergePetFragments=(fragment,totalFragments,fragmentNumber,fragments)=>{if(totalFragments===1)return fragment;fragments[fragmentNumber]=fragment;for(const frag of fragments){if(!frag)return null;}const merged=new Map();for(const frag of fragments){for(const[key,value]of frag)merged.set(key,value);frag.clear();}fragments=null;return merged;};","map":null,"metadata":{},"sourceType":"module"}