{"ast":null,"code":"/* eslint-disable */ /*!\n * @pixi/tilemap - v3.2.2\n * Compiled Fri, 22 Oct 2021 12:27:49 UTC\n *\n * @pixi/tilemap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n * \n * Copyright 2019-2020, Ivan Popelyshev, All Rights Reserved\n */import{Container,Bounds}from'@pixi/display';import{Texture,Resource,Shader,Program,Geometry,Buffer,ObjectRenderer,BaseTexture,Renderer}from'@pixi/core';import{SCALE_MODES,DRAW_MODES,ALPHA_MODES,WRAP_MODES}from'@pixi/constants';import{groupD8,Matrix}from'@pixi/math';import{createIndicesForQuads}from'@pixi/utils';/**\r\n * The renderer plugin for canvas. It isn't registered by default.\r\n *\r\n * ```\r\n * import { CanvasTileRenderer } from '@pixi/tilemap';\r\n * import { CanvasRenderer } from '@pixi/canvas-core';\r\n *\r\n * // You must register this yourself (optional). @pixi/tilemap doesn't do it to\r\n * // prevent a hard dependency on @pixi/canvas-core.\r\n * CanvasRenderer.registerPlugin('tilemap', CanvasTileRenderer);\r\n * ```\r\n */ // TODO: Move to @pixi/tilemap-canvas\nclass CanvasTileRenderer{/** The renderer */ /** The global tile animation state */__init(){this.tileAnim=[0,0];}/** @deprecated */__init2(){this.dontUseTransform=false;}/** @param renderer */constructor(renderer){CanvasTileRenderer.prototype.__init.call(this);CanvasTileRenderer.prototype.__init2.call(this);this.renderer=renderer;this.tileAnim=[0,0];}// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nstatic getInstance(renderer){if(!renderer.plugins.tilemap){renderer.plugins.tilemap=new CanvasTileRenderer(renderer);}return renderer.plugins.tilemap;}}/**\r\n * These are additional @pixi/tilemap options.\r\n *\r\n * This settings should not be changed after the renderer has initialized; otherwise, the behavior\r\n * is undefined.\r\n */const settings={/** The default number of textures per tilemap in a tilemap composite. */TEXTURES_PER_TILEMAP:16,/**\r\n     * The width/height of each texture tile in a {@link TEXTILE_DIMEN}. This is 1024px by default.\r\n     *\r\n     * This should fit all tile base-textures; otherwise, {@link TextileResource} may fail to correctly\r\n     * upload the textures togther in a tiled fashion.\r\n     */TEXTILE_DIMEN:1024,/**\r\n     * The number of texture tiles per {@link TextileResource}.\r\n     *\r\n     * Texture tiling is disabled by default, and so this is set to `1` by default. If it is set to a\r\n     * higher value, textures will be uploaded together in a tiled fashion.\r\n     *\r\n     * Since {@link TextileResource} is a dual-column format, this should be even for packing\r\n     * efficiency. The optimal value is usually 4.\r\n     */TEXTILE_UNITS:1,/** The scaling mode of the combined texture tiling. */TEXTILE_SCALE_MODE:SCALE_MODES.LINEAR,/** This will enable 32-bit index buffers. It's useful when you have more than 16K tiles. */use32bitIndex:false,/** Flags whether textiles should be cleared when each tile is uploaded. */DO_CLEAR:true,// Backward compatibility\nget maxTextures(){return this.MAX_TEXTURES;},set maxTextures(value){this.MAX_TEXTURES=value;},get boundSize(){return this.TEXTURE_TILE_DIMEN;},set boundSize(value){this.TILE_TEXTURE_DIMEN=value;},get boundCountPerBuffer(){return this.TEXTILE_UNITS;},set boundCountPerBuffer(value){this.TEXTILE_UNITS=value;}};// @deprecated\nconst Constant=settings;function _nullishCoalesce(lhs,rhsFn){if(lhs!=null){return lhs;}else{return rhsFn();}}var POINT_STRUCT;(function(POINT_STRUCT){const U=0;POINT_STRUCT[POINT_STRUCT[\"U\"]=U]=\"U\";const V=U+1;POINT_STRUCT[POINT_STRUCT[\"V\"]=V]=\"V\";const X=V+1;POINT_STRUCT[POINT_STRUCT[\"X\"]=X]=\"X\";const Y=X+1;POINT_STRUCT[POINT_STRUCT[\"Y\"]=Y]=\"Y\";const TILE_WIDTH=Y+1;POINT_STRUCT[POINT_STRUCT[\"TILE_WIDTH\"]=TILE_WIDTH]=\"TILE_WIDTH\";const TILE_HEIGHT=TILE_WIDTH+1;POINT_STRUCT[POINT_STRUCT[\"TILE_HEIGHT\"]=TILE_HEIGHT]=\"TILE_HEIGHT\";const ROTATE=TILE_HEIGHT+1;POINT_STRUCT[POINT_STRUCT[\"ROTATE\"]=ROTATE]=\"ROTATE\";const ANIM_X=ROTATE+1;POINT_STRUCT[POINT_STRUCT[\"ANIM_X\"]=ANIM_X]=\"ANIM_X\";const ANIM_Y=ANIM_X+1;POINT_STRUCT[POINT_STRUCT[\"ANIM_Y\"]=ANIM_Y]=\"ANIM_Y\";const TEXTURE_INDEX=ANIM_Y+1;POINT_STRUCT[POINT_STRUCT[\"TEXTURE_INDEX\"]=TEXTURE_INDEX]=\"TEXTURE_INDEX\";const ANIM_COUNT_X=TEXTURE_INDEX+1;POINT_STRUCT[POINT_STRUCT[\"ANIM_COUNT_X\"]=ANIM_COUNT_X]=\"ANIM_COUNT_X\";const ANIM_COUNT_Y=ANIM_COUNT_X+1;POINT_STRUCT[POINT_STRUCT[\"ANIM_COUNT_Y\"]=ANIM_COUNT_Y]=\"ANIM_COUNT_Y\";const ANIM_DIVISOR=ANIM_COUNT_Y+1;POINT_STRUCT[POINT_STRUCT[\"ANIM_DIVISOR\"]=ANIM_DIVISOR]=\"ANIM_DIVISOR\";const ALPHA=ANIM_DIVISOR+1;POINT_STRUCT[POINT_STRUCT[\"ALPHA\"]=ALPHA]=\"ALPHA\";})(POINT_STRUCT||(POINT_STRUCT={}));const POINT_STRUCT_SIZE=Object.keys(POINT_STRUCT).length/2;/**\r\n * A rectangular tilemap implementation that renders a predefined set of tile textures.\r\n *\r\n * The {@link Tilemap.tileset tileset} of a tilemap defines the list of base-textures that can be painted in the\r\n * tilemap. A texture is identified using its base-texture's index into the this list, i.e. changing the base-texture\r\n * at a given index in the tileset modifies the paint of all tiles pointing to that index.\r\n *\r\n * The size of the tileset is limited by the texture units supported by the client device. The minimum supported\r\n * value is 8, as defined by the WebGL 1 specification. `gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS`) can be used\r\n * to extract this limit. {@link CompositeTilemap} can be used to get around this limit by layering multiple tilemap\r\n * instances.\r\n *\r\n * @example\r\n * import { Tilemap } from '@pixi/tilemap';\r\n * import { Loader } from '@pixi/loaders';\r\n *\r\n * // Add the spritesheet into your loader!\r\n * Loader.shared.add('atlas', 'assets/atlas.json');\r\n *\r\n * // Make the tilemap once the tileset assets are available.\r\n * Loader.shared.load(function onTilesetLoaded()\r\n * {\r\n *      // The base-texture is shared between all the tile textures.\r\n *      const tilemap = new Tilemap([Texture.from('grass.png').baseTexture])\r\n *          .tile('grass.png', 0, 0)\r\n *          .tile('grass.png', 100, 100)\r\n *          .tile('brick_wall.png', 0, 100);\r\n * });\r\n */class Tilemap extends Container{__init(){this.shadowColor=new Float32Array([0.0,0.0,0.0,0.5]);}__init2(){this._globalMat=null;}/**\r\n     * The tile animation frame.\r\n     *\r\n     * @see CompositeTilemap.tileAnim\r\n     */__init3(){this.tileAnim=null;}/**\r\n     * This is the last uploaded size of the tilemap geometry.\r\n     * @ignore\r\n     */__init4(){this.modificationMarker=0;}/** @ignore */__init5(){this.offsetX=0;}/** @ignore */__init6(){this.offsetY=0;}/** @ignore */__init7(){this.compositeParent=false;}/**\r\n     * The list of base-textures being used in the tilemap.\r\n     *\r\n     * This should not be shuffled after tiles have been added into this tilemap. Usually, only tile textures\r\n     * should be added after tiles have been added into the map.\r\n     */ /**\r\n     * The local bounds of the tilemap itself. This does not include DisplayObject children.\r\n     */__init8(){this.tilemapBounds=new Bounds();}/** Flags whether any animated tile was added. */__init9(){this.hasAnimatedTile=false;}/** The interleaved geometry of the tilemap. */__init10(){this.pointsBuf=[];}/**\r\n     * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}. The\r\n     *      base-textures in this array must not be duplicated.\r\n     */constructor(tileset){super();Tilemap.prototype.__init.call(this);Tilemap.prototype.__init2.call(this);Tilemap.prototype.__init3.call(this);Tilemap.prototype.__init4.call(this);Tilemap.prototype.__init5.call(this);Tilemap.prototype.__init6.call(this);Tilemap.prototype.__init7.call(this);Tilemap.prototype.__init8.call(this);Tilemap.prototype.__init9.call(this);Tilemap.prototype.__init10.call(this);Tilemap.prototype.__init11.call(this);Tilemap.prototype.__init12.call(this);Tilemap.prototype.__init13.call(this);Tilemap.prototype.__init14.call(this);Tilemap.prototype.__init15.call(this);Tilemap.prototype.__init16.call(this);this.setTileset(tileset);}/**\r\n     * @returns The tileset of this tilemap.\r\n     */getTileset(){return this.tileset;}/**\r\n     * Define the tileset used by the tilemap.\r\n     *\r\n     * @param tileset - The list of textures to use in the tilemap. If a base-texture (not array) is passed, it will\r\n     *  be wrapped into an array. This should not contain any duplicates.\r\n     */setTileset(){let tileset=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];if(!Array.isArray(tileset)){tileset=[tileset];}for(let i=0;i<tileset.length;i++){if(tileset[i].baseTexture){tileset[i]=tileset[i].baseTexture;}}this.tileset=tileset;return this;}/**  Clears all the tiles added into this tilemap. */clear(){this.pointsBuf.length=0;this.modificationMarker=0;this.tilemapBounds.clear();this.hasAnimatedTile=false;return this;}/**\r\n     * Adds a tile that paints the given texture at (x, y).\r\n     *\r\n     * @param tileTexture - The tiling texture to render.\r\n     * @param x - The local x-coordinate of the tile's position.\r\n     * @param y - The local y-coordinate of the tile's position.\r\n     * @param options - Additional tile options.\r\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\r\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\r\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\r\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\r\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\r\n     *      animation frame textures in the base-texture.\r\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\r\n     *      animation frames textures in the base-texture.\r\n     * @param [options.rotate=0]\r\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per row.\r\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per column.\r\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration of each frame\r\n     * @param [options.alpha=1] - Tile alpha\r\n     * @return This tilemap, good for chaining.\r\n     */tile(tileTexture,x,y){let options=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};let baseTexture;let textureIndex=-1;if(typeof tileTexture==='number'){textureIndex=tileTexture;baseTexture=this.tileset[textureIndex];}else{let texture;if(typeof tileTexture==='string'){texture=Texture.from(tileTexture);}else{texture=tileTexture;}const textureList=this.tileset;for(let i=0;i<textureList.length;i++){if(textureList[i]===texture.castToBaseTexture()){textureIndex=i;break;}}if('baseTexture'in texture){options.u=_nullishCoalesce(options.u,()=>texture.frame.x);options.v=_nullishCoalesce(options.v,()=>texture.frame.y);options.tileWidth=_nullishCoalesce(options.tileWidth,()=>texture.orig.width);options.tileHeight=_nullishCoalesce(options.tileHeight,()=>texture.orig.height);}baseTexture=texture.castToBaseTexture();}if(!baseTexture||textureIndex<0){console.error('The tile texture was not found in the tilemap tileset.');return this;}const{u=0,v=0,tileWidth=baseTexture.realWidth,tileHeight=baseTexture.realHeight,animX=0,animY=0,rotate=0,animCountX=1024,animCountY=1024,animDivisor=1,alpha=1}=options;const pb=this.pointsBuf;this.hasAnimatedTile=this.hasAnimatedTile||animX>0||animY>0;pb.push(u);pb.push(v);pb.push(x);pb.push(y);pb.push(tileWidth);pb.push(tileHeight);pb.push(rotate);pb.push(animX|0);pb.push(animY|0);pb.push(textureIndex);pb.push(animCountX);pb.push(animCountY);pb.push(animDivisor);pb.push(alpha);this.tilemapBounds.addFramePad(x,y,x+tileWidth,y+tileHeight,0,0);return this;}/** Changes the rotation of the last tile. */tileRotate(rotate){const pb=this.pointsBuf;pb[pb.length-(POINT_STRUCT_SIZE-POINT_STRUCT.TEXTURE_INDEX)]=rotate;}/** Changes the `animX`, `animCountX` of the last tile. */tileAnimX(offset,count){const pb=this.pointsBuf;pb[pb.length-(POINT_STRUCT_SIZE-POINT_STRUCT.ANIM_X)]=offset;pb[pb.length-(POINT_STRUCT_SIZE-POINT_STRUCT.ANIM_COUNT_X)]=count;// pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = duration;\n}/** Changes the `animY`, `animCountY` of the last tile. */tileAnimY(offset,count){const pb=this.pointsBuf;pb[pb.length-(POINT_STRUCT_SIZE-POINT_STRUCT.ANIM_Y)]=offset;pb[pb.length-(POINT_STRUCT_SIZE-POINT_STRUCT.ANIM_COUNT_Y)]=count;}/** Changes the `animDivisor` value of the last tile. */tileAnimDivisor(divisor){const pb=this.pointsBuf;pb[pb.length-(POINT_STRUCT_SIZE-POINT_STRUCT.ANIM_DIVISOR)]=divisor;}tileAlpha(alpha){const pb=this.pointsBuf;pb[pb.length-(POINT_STRUCT_SIZE-POINT_STRUCT.ALPHA)]=alpha;}__init11(){this.renderCanvas=renderer=>{const plugin=CanvasTileRenderer.getInstance(renderer);if(plugin&&!plugin.dontUseTransform){const wt=this.worldTransform;renderer.context.setTransform(wt.a,wt.b,wt.c,wt.d,wt.tx*renderer.resolution,wt.ty*renderer.resolution);}this.renderCanvasCore(renderer);};}renderCanvasCore(renderer){if(this.tileset.length===0)return;const points=this.pointsBuf;const tileAnim=this.tileAnim||renderer.plugins.tilemap&&renderer.plugins.tilemap.tileAnim;renderer.context.fillStyle='#000000';for(let i=0,n=points.length;i<n;i+=POINT_STRUCT_SIZE){let x1=points[i+POINT_STRUCT.U];let y1=points[i+POINT_STRUCT.V];const x2=points[i+POINT_STRUCT.X];const y2=points[i+POINT_STRUCT.Y];const w=points[i+POINT_STRUCT.TILE_WIDTH];const h=points[i+POINT_STRUCT.TILE_HEIGHT];x1+=points[i+POINT_STRUCT.ANIM_X]*tileAnim[0];y1+=points[i+POINT_STRUCT.ANIM_Y]*tileAnim[1];const textureIndex=points[i+POINT_STRUCT.TEXTURE_INDEX];const alpha=points[i+POINT_STRUCT.ALPHA];// canvas does not work with rotate yet\nif(textureIndex>=0&&this.tileset[textureIndex]){renderer.context.globalAlpha=alpha;renderer.context.drawImage(this.tileset[textureIndex].getDrawableSource(),x1,y1,w,h,x2,y2,w,h);}else{renderer.context.globalAlpha=0.5;renderer.context.fillRect(x2,y2,w,h);}renderer.context.globalAlpha=1;}}__init12(){this.vbId=0;}__init13(){this.vb=null;}__init14(){this.vbBuffer=null;}__init15(){this.vbArray=null;}__init16(){this.vbInts=null;}destroyVb(){if(this.vb){this.vb.destroy();this.vb=null;}}render(renderer){const plugin=renderer.plugins.tilemap;const shader=plugin.getShader();renderer.batch.setObjectRenderer(plugin);this._globalMat=shader.uniforms.projTransMatrix;renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);shader.uniforms.shadowColor=this.shadowColor;shader.uniforms.animationFrame=this.tileAnim||plugin.tileAnim;this.renderWebGLCore(renderer,plugin);}renderWebGLCore(renderer,plugin){const points=this.pointsBuf;if(points.length===0)return;const rectsCount=points.length/POINT_STRUCT_SIZE;const shader=plugin.getShader();const textures=this.tileset;if(textures.length===0)return;plugin.bindTileTextures(renderer,textures);renderer.shader.bind(shader,false);// lost context! recover!\nlet vb=this.vb;if(!vb){vb=plugin.createVb();this.vb=vb;this.vbId=vb.id;this.vbBuffer=null;this.modificationMarker=0;}plugin.checkIndexBuffer(rectsCount,vb);const boundCountPerBuffer=settings.TEXTILE_UNITS;const vertexBuf=vb.getBuffer('aVertexPosition');// if layer was changed, re-upload vertices\nconst vertices=rectsCount*vb.vertPerQuad;if(vertices===0)return;if(this.modificationMarker!==vertices){this.modificationMarker=vertices;const vs=vb.stride*vertices;if(!this.vbBuffer||this.vbBuffer.byteLength<vs){// !@#$ happens, need resize\nlet bk=vb.stride;while(bk<vs){bk*=2;}this.vbBuffer=new ArrayBuffer(bk);this.vbArray=new Float32Array(this.vbBuffer);this.vbInts=new Uint32Array(this.vbBuffer);vertexBuf.update(this.vbBuffer);}const arr=this.vbArray;// const ints = this.vbInts;\n// upload vertices!\nlet sz=0;// let tint = 0xffffffff;\nlet textureId=0;let shiftU=this.offsetX;let shiftV=this.offsetY;// let tint = 0xffffffff;\n// const tint = -1;\nfor(let i=0;i<points.length;i+=POINT_STRUCT_SIZE){const eps=0.5;if(this.compositeParent){const textureIndex=points[i+POINT_STRUCT.TEXTURE_INDEX];if(boundCountPerBuffer>1){// TODO: what if its more than 4?\ntextureId=textureIndex>>2;shiftU=this.offsetX*(textureIndex&1);shiftV=this.offsetY*(textureIndex>>1&1);}else{textureId=textureIndex;shiftU=0;shiftV=0;}}const x=points[i+POINT_STRUCT.X];const y=points[i+POINT_STRUCT.Y];const w=points[i+POINT_STRUCT.TILE_WIDTH];const h=points[i+POINT_STRUCT.TILE_HEIGHT];const u=points[i+POINT_STRUCT.U]+shiftU;const v=points[i+POINT_STRUCT.V]+shiftV;let rotate=points[i+POINT_STRUCT.ROTATE];const animX=points[i+POINT_STRUCT.ANIM_X];const animY=points[i+POINT_STRUCT.ANIM_Y];const animWidth=points[i+POINT_STRUCT.ANIM_COUNT_X]||1024;const animHeight=points[i+POINT_STRUCT.ANIM_COUNT_Y]||1024;const animXEncoded=animX+animWidth*2048;const animYEncoded=animY+animHeight*2048;const animDivisor=points[i+POINT_STRUCT.ANIM_DIVISOR];const alpha=points[i+POINT_STRUCT.ALPHA];let u0;let v0;let u1;let v1;let u2;let v2;let u3;let v3;if(rotate===0){u0=u;v0=v;u1=u+w;v1=v;u2=u+w;v2=v+h;u3=u;v3=v+h;}else{let w2=w/2;let h2=h/2;if(rotate%4!==0){w2=h/2;h2=w/2;}const cX=u+w2;const cY=v+h2;rotate=groupD8.add(rotate,groupD8.NW);u0=cX+w2*groupD8.uX(rotate);v0=cY+h2*groupD8.uY(rotate);rotate=groupD8.add(rotate,2);// rotate 90 degrees clockwise\nu1=cX+w2*groupD8.uX(rotate);v1=cY+h2*groupD8.uY(rotate);rotate=groupD8.add(rotate,2);u2=cX+w2*groupD8.uX(rotate);v2=cY+h2*groupD8.uY(rotate);rotate=groupD8.add(rotate,2);u3=cX+w2*groupD8.uX(rotate);v3=cY+h2*groupD8.uY(rotate);}arr[sz++]=x;arr[sz++]=y;arr[sz++]=u0;arr[sz++]=v0;arr[sz++]=u+eps;arr[sz++]=v+eps;arr[sz++]=u+w-eps;arr[sz++]=v+h-eps;arr[sz++]=animXEncoded;arr[sz++]=animYEncoded;arr[sz++]=textureId;arr[sz++]=animDivisor;arr[sz++]=alpha;arr[sz++]=x+w;arr[sz++]=y;arr[sz++]=u1;arr[sz++]=v1;arr[sz++]=u+eps;arr[sz++]=v+eps;arr[sz++]=u+w-eps;arr[sz++]=v+h-eps;arr[sz++]=animXEncoded;arr[sz++]=animYEncoded;arr[sz++]=textureId;arr[sz++]=animDivisor;arr[sz++]=alpha;arr[sz++]=x+w;arr[sz++]=y+h;arr[sz++]=u2;arr[sz++]=v2;arr[sz++]=u+eps;arr[sz++]=v+eps;arr[sz++]=u+w-eps;arr[sz++]=v+h-eps;arr[sz++]=animXEncoded;arr[sz++]=animYEncoded;arr[sz++]=textureId;arr[sz++]=animDivisor;arr[sz++]=alpha;arr[sz++]=x;arr[sz++]=y+h;arr[sz++]=u3;arr[sz++]=v3;arr[sz++]=u+eps;arr[sz++]=v+eps;arr[sz++]=u+w-eps;arr[sz++]=v+h-eps;arr[sz++]=animXEncoded;arr[sz++]=animYEncoded;arr[sz++]=textureId;arr[sz++]=animDivisor;arr[sz++]=alpha;}vertexBuf.update(arr);}renderer.geometry.bind(vb,shader);renderer.geometry.draw(DRAW_MODES.TRIANGLES,rectsCount*6,0);}/**\r\n     * @internal\r\n     * @ignore\r\n     */isModified(anim){if(this.modificationMarker!==this.pointsBuf.length||anim&&this.hasAnimatedTile){return true;}return false;}/**\r\n     * This will pull forward the modification marker.\r\n     *\r\n     * @internal\r\n     * @ignore\r\n     */clearModify(){this.modificationMarker=this.pointsBuf.length;}/** @override */_calculateBounds(){const{minX,minY,maxX,maxY}=this.tilemapBounds;this._bounds.addFrame(this.transform,minX,minY,maxX,maxY);}/** @override */getLocalBounds(rect){// we can do a fast local bounds if the sprite has no children!\nif(this.children.length===0){return this.tilemapBounds.getRectangle(rect);}return super.getLocalBounds.call(this,rect);}/** @override */destroy(options){super.destroy(options);this.destroyVb();}/**\r\n     * Deprecated signature for {@link Tilemap.tile tile}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */addFrame(texture,x,y,animX,animY){this.tile(texture,x,y,{animX,animY});return true;}/**\r\n     * Deprecated signature for {@link Tilemap.tile tile}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */ // eslint-disable-next-line max-params\naddRect(textureIndex,u,v,x,y,tileWidth,tileHeight){let animX=arguments.length>7&&arguments[7]!==undefined?arguments[7]:0;let animY=arguments.length>8&&arguments[8]!==undefined?arguments[8]:0;let rotate=arguments.length>9&&arguments[9]!==undefined?arguments[9]:0;let animCountX=arguments.length>10&&arguments[10]!==undefined?arguments[10]:1024;let animCountY=arguments.length>11&&arguments[11]!==undefined?arguments[11]:1024;let animDivisor=arguments.length>12&&arguments[12]!==undefined?arguments[12]:1;let alpha=arguments.length>13&&arguments[13]!==undefined?arguments[13]:1;return this.tile(textureIndex,x,y,{u,v,tileWidth,tileHeight,animX,animY,rotate,animCountX,animCountY,animDivisor,alpha});}}/**\r\n * A tilemap composite that lazily builds tilesets layered into multiple tilemaps.\r\n *\r\n * The composite tileset is the concatenatation of the individual tilesets used in the tilemaps. You can\r\n * preinitialized it by passing a list of tile textures to the constructor. Otherwise, the composite tilemap\r\n * is lazily built as you add more tiles with newer tile textures. A new tilemap is created once the last\r\n * tilemap has reached its limit (as set by {@link CompositeTilemap.texturesPerTilemap texturesPerTilemap}).\r\n *\r\n * @example\r\n * import { Application } from '@pixi/app';\r\n * import { CompositeTilemap } from '@pixi/tilemap';\r\n * import { Loader } from '@pixi/loaders';\r\n *\r\n * // Setup view & stage.\r\n * const app = new Application();\r\n *\r\n * document.body.appendChild(app.renderer.view);\r\n * app.stage.interactive = true;\r\n *\r\n * // Global reference to the tilemap.\r\n * let globalTilemap: CompositeTilemap;\r\n *\r\n * // Load the tileset spritesheet!\r\n * Loader.shared.load('atlas.json');\r\n *\r\n * // Initialize the tilemap scene when the assets load.\r\n * Loader.shared.load(function onTilesetLoaded()\r\n * {\r\n *      const tilemap = new CompositeTilemap();\r\n *\r\n *      // Setup the game level with grass and dungeons!\r\n *      for (let x = 0; x < 10; x++)\r\n *      {\r\n *          for (let y = 0; y < 10; y++)\r\n *          {\r\n *              tilemap.tile(\r\n *                  x % 2 === 0 && (x === y || x + y === 10) ? 'dungeon.png' : 'grass.png',\r\n *                  x * 100,\r\n *                  y * 100,\r\n *              );\r\n *          }\r\n *      }\r\n *\r\n *      globalTilemap = app.stage.addChild(tilemap);\r\n * });\r\n *\r\n * // Show a bomb at a random location whenever the user clicks!\r\n * app.stage.on('click', function onClick()\r\n * {\r\n *      if (!globalTilemap) return;\r\n *\r\n *      const x = Math.floor(Math.random() * 10);\r\n *      const y = Math.floor(Math.random() * 10);\r\n *\r\n *      globalTilemap.tile('bomb.png', x * 100, y * 100);\r\n * });\r\n */class CompositeTilemap extends Container{/** The hard limit on the number of tile textures used in each tilemap. */ /**\r\n     * The animation frame vector.\r\n     *\r\n     * Animated tiles have four parameters - `animX`, `animY`, `animCountX`, `animCountY`. The textures\r\n     * of adjacent animation frames are at offset `animX` or `animY` of each other, with `animCountX` per\r\n     * row and `animCountY` per column.\r\n     *\r\n     * The animation frame vector specifies which animation frame texture to use. If the x/y coordinate is\r\n     * larger than the `animCountX` or `animCountY` for a specific tile, the modulus is taken.\r\n     */__init(){this.tileAnim=null;}/** The last modified tilemap. */__init2(){this.lastModifiedTilemap=null;}__init3(){this.modificationMarker=0;}__init4(){this.shadowColor=new Float32Array([0.0,0.0,0.0,0.5]);}__init5(){this._globalMat=null;}/**\r\n     * @param tileset - A list of tile base-textures that will be used to eagerly initialized the layered\r\n     *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}\r\n     *  will work equivalently.\r\n     */constructor(tileset){super();CompositeTilemap.prototype.__init.call(this);CompositeTilemap.prototype.__init2.call(this);CompositeTilemap.prototype.__init3.call(this);CompositeTilemap.prototype.__init4.call(this);CompositeTilemap.prototype.__init5.call(this);CompositeTilemap.prototype.__init6.call(this);this.tileset(tileset);this.texturesPerTilemap=settings.TEXTURES_PER_TILEMAP;}/**\r\n     * This will preinitialize the tilesets of the layered tilemaps.\r\n     *\r\n     * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the\r\n     * existing tilemaps. Passing the tileset to the constructor instead is the best practice.\r\n     *\r\n     * @param tileTextures - The list of tile textures that make up the tileset.\r\n     */tileset(tileTextures){if(!tileTextures){tileTextures=[];}const texPerChild=this.texturesPerTilemap;const len1=this.children.length;const len2=Math.ceil(tileTextures.length/texPerChild);for(let i=0;i<Math.min(len1,len2);i++){this.children[i].setTileset(tileTextures.slice(i*texPerChild,(i+1)*texPerChild));}for(let i=len1;i<len2;i++){const tilemap=new Tilemap(tileTextures.slice(i*texPerChild,(i+1)*texPerChild));tilemap.compositeParent=true;tilemap.offsetX=settings.TEXTILE_DIMEN;tilemap.offsetY=settings.TEXTILE_DIMEN;// TODO: Don't use children\nthis.addChild(tilemap);}return this;}/** Clears the tilemap composite. */clear(){for(let i=0;i<this.children.length;i++){this.children[i].clear();}this.modificationMarker=0;return this;}/** Changes the rotation of the last added tile. */tileRotate(rotate){if(this.lastModifiedTilemap){this.lastModifiedTilemap.tileRotate(rotate);}return this;}/** Changes `animX`, `animCountX` of the last added tile. */tileAnimX(offset,count){if(this.lastModifiedTilemap){this.lastModifiedTilemap.tileAnimX(offset,count);}return this;}/** Changes `animY`, `animCountY` of the last added tile. */tileAnimY(offset,count){if(this.lastModifiedTilemap){this.lastModifiedTilemap.tileAnimY(offset,count);}return this;}/** Changes `tileAnimDivisor` value of the last added tile. */tileAnimDivisor(divisor){if(this.lastModifiedTilemap){this.lastModifiedTilemap.tileAnimDivisor(divisor);}return this;}/**\r\n     * Adds a tile that paints the given tile texture at (x, y).\r\n     *\r\n     * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.\r\n     * @param x - The local x-coordinate of the tile's location.\r\n     * @param y - The local y-coordinate of the tile's location.\r\n     * @param options - Additional options to pass to {@link Tilemap.tile}.\r\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\r\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\r\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\r\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\r\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\r\n     *      animation frame textures in the base-texture.\r\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\r\n     *      animation frames textures in the base-texture.\r\n     * @param [options.rotate=0]\r\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per row.\r\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per column.\r\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration each frame\r\n     * @param [options.alpha=1] - Tile alpha\r\n     * @return This tilemap, good for chaining.\r\n     */tile(tileTexture,x,y){let options=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};let tilemap=null;const children=this.children;this.lastModifiedTilemap=null;if(typeof tileTexture==='number'){const childIndex=tileTexture/this.texturesPerTilemap>>0;let tileIndex=0;tilemap=children[childIndex];if(!tilemap){tilemap=children[0];// Silently fail if the tilemap doesn't exist\nif(!tilemap)return this;tileIndex=0;}else{tileIndex=tileTexture%this.texturesPerTilemap;}tilemap.tile(tileIndex,x,y,options);}else{if(typeof tileTexture==='string'){tileTexture=Texture.from(tileTexture);}// Probe all tilemaps to find which tileset contains the base-texture.\nfor(let i=0;i<children.length;i++){const child=children[i];const tex=child.getTileset();for(let j=0;j<tex.length;j++){if(tex[j]===tileTexture.baseTexture){tilemap=child;break;}}if(tilemap){break;}}// If no tileset contains the base-texture, attempt to add it.\nif(!tilemap){// Probe the tilemaps to find one below capacity. If so, add the texture into that tilemap.\nfor(let i=children.length-1;i>=0;i--){const child=children[i];if(child.getTileset().length<this.texturesPerTilemap){tilemap=child;child.getTileset().push(tileTexture.baseTexture);break;}}// Otherwise, create a new tilemap initialized with that tile texture.\nif(!tilemap){tilemap=new Tilemap(tileTexture.baseTexture);tilemap.compositeParent=true;tilemap.offsetX=settings.TEXTILE_DIMEN;tilemap.offsetY=settings.TEXTILE_DIMEN;this.addChild(tilemap);}}tilemap.tile(tileTexture,x,y,options);}this.lastModifiedTilemap=tilemap;return this;}renderCanvas(renderer){if(!this.visible||this.worldAlpha<=0||!this.renderable){return;}const tilemapPlugin=CanvasTileRenderer.getInstance(renderer);if(tilemapPlugin&&!tilemapPlugin.dontUseTransform){const wt=this.worldTransform;renderer.context.setTransform(wt.a,wt.b,wt.c,wt.d,wt.tx*renderer.resolution,wt.ty*renderer.resolution);}const layers=this.children;for(let i=0;i<layers.length;i++){const layer=layers[i];layer.tileAnim=this.tileAnim;layer.renderCanvasCore(renderer);}}render(renderer){if(!this.visible||this.worldAlpha<=0||!this.renderable){return;}const plugin=renderer.plugins.tilemap;const shader=plugin.getShader();renderer.batch.setObjectRenderer(plugin);// TODO: dont create new array, please\nthis._globalMat=shader.uniforms.projTransMatrix;renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);shader.uniforms.shadowColor=this.shadowColor;shader.uniforms.animationFrame=this.tileAnim||plugin.tileAnim;renderer.shader.bind(shader,false);const layers=this.children;for(let i=0;i<layers.length;i++){layers[i].renderWebGLCore(renderer,plugin);}}/**\r\n     * @internal\r\n     * @ignore\r\n     */isModified(anim){const layers=this.children;if(this.modificationMarker!==layers.length){return true;}for(let i=0;i<layers.length;i++){if(layers[i].isModified(anim)){return true;}}return false;}/**\r\n     * @internal\r\n     * @ignore\r\n     */clearModify(){const layers=this.children;this.modificationMarker=layers.length;for(let i=0;i<layers.length;i++){layers[i].clearModify();}}/**\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     * @see CompositeTilemap.tile\r\n     */addFrame(texture,x,y,animX,animY,animWidth,animHeight,animDivisor,alpha){return this.tile(texture,x,y,{animX,animY,animCountX:animWidth,animCountY:animHeight,animDivisor,alpha});}/**\r\n     * @deprecated @pixi/tilemap 3\r\n     * @see CompositeTilemap.tile\r\n     */ // eslint-disable-next-line max-params\naddRect(textureIndex,u,v,x,y,tileWidth,tileHeight,animX,animY,rotate,animWidth,animHeight){const childIndex=textureIndex/this.texturesPerTilemap>>0;const textureId=textureIndex%this.texturesPerTilemap;if(this.children[childIndex]&&this.children[childIndex].getTileset()){this.lastModifiedTilemap=this.children[childIndex];this.lastModifiedTilemap.addRect(textureId,u,v,x,y,tileWidth,tileHeight,animX,animY,rotate,animWidth,animHeight);}else{this.lastModifiedTilemap=null;}return this;}/**\r\n     * Alias for {@link CompositeTilemap.tileset tileset}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */__init6(){this.setBitmaps=this.tileset;}/**\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     * @readonly\r\n     * @see CompositeTilemap.texturesPerTilemap\r\n     */get texPerChild(){return this.texturesPerTilemap;}}// For some reason ESLint goes mad with indendation in this file ^&^\n/* eslint-disable indent */ /**\r\n * This texture tiling resource can be used to upload multiple base-textures together.\r\n *\r\n * This resource combines multiple base-textures into a \"textile\". They're laid out in\r\n * a dual column format, placed in row-order order. The size of each tile is predefined,\r\n * and defaults to {@link settings.TEXTILE_DIMEN}. This means that each input base-texture\r\n * must is smaller than that along both its width and height.\r\n *\r\n * @see settings.TEXTILE_UNITS\r\n */class TextileResource extends Resource{/** The base-texture that contains all the texture tiles. */__init(){this.baseTexture=null;}__init2(){this._clearBuffer=null;}/**\r\n\t * @param options - This will default to the \"settings\" exported by @pixi/tilemap.\r\n\t * @param options.TEXTILE_DIMEN - The dimensions of each tile.\r\n\t * @param options.TEXTILE_UNITS - The number of texture tiles.\r\n\t */constructor(){let options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:settings;super(options.TEXTILE_DIMEN*2,options.TEXTILE_DIMEN*Math.ceil(options.TEXTILE_UNITS/2));TextileResource.prototype.__init.call(this);TextileResource.prototype.__init2.call(this);const tiles=this.tiles=new Array(options.TEXTILE_UNITS);this.doClear=!!options.DO_CLEAR;this.tileDimen=options.TEXTILE_DIMEN;for(let j=0;j<options.TEXTILE_UNITS;j++){tiles[j]={dirtyId:0,x:options.TEXTILE_DIMEN*(j&1),y:options.TEXTILE_DIMEN*(j>>1),baseTexture:Texture.WHITE.baseTexture};}}/**\r\n\t * Sets the texture to be uploaded for the given tile.\r\n\t *\r\n\t * @param index - The index of the tile being set.\r\n\t * @param texture - The texture with the base-texture to upload.\r\n\t */tile(index,texture){const tile=this.tiles[index];if(tile.baseTexture===texture){return;}tile.baseTexture=texture;this.baseTexture.update();this.tiles[index].dirtyId=this.baseTexture.dirtyId;}/** @override */bind(baseTexture){if(this.baseTexture){throw new Error('Only one baseTexture is allowed for this resource!');}this.baseTexture=baseTexture;super.bind(baseTexture);}/** @override */upload(renderer,texture,glTexture){const{gl}=renderer;const{width,height}=this;gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.alphaMode===undefined||texture.alphaMode===ALPHA_MODES.UNPACK);if(glTexture.dirtyId<0){glTexture.width=width;glTexture.height=height;gl.texImage2D(texture.target,0,texture.format,width,height,0,texture.format,texture.type,null);}const doClear=this.doClear;const tiles=this.tiles;if(doClear&&!this._clearBuffer){this._clearBuffer=new Uint8Array(settings.TEXTILE_DIMEN*settings.TEXTILE_DIMEN*4);}for(let i=0;i<tiles.length;i++){const spr=tiles[i];const tex=spr.baseTexture;if(glTexture.dirtyId>=this.tiles[i].dirtyId){continue;}const res=tex.resource;if(!tex.valid||!res||!res.source){continue;}if(doClear&&(tex.width<this.tileDimen||tex.height<this.tileDimen)){gl.texSubImage2D(texture.target,0,spr.x,spr.y,this.tileDimen,this.tileDimen,texture.format,texture.type,this._clearBuffer);}gl.texSubImage2D(texture.target,0,spr.x,spr.y,texture.format,texture.type,res.source);}return true;}}/**\r\n * This will generate fragment shader code that samples the correct texture into the \"color\" variable.\r\n *\r\n * @internal\r\n * @ignore\r\n * @param maxTextures - The texture array length in the shader's uniforms.\r\n */function generateSampleSrc(maxTextures){let src='';src+='\\n';src+='\\n';src+='if(vTextureId <= -1.0) {';src+='\\n\\tcolor = shadowColor;';src+='\\n}';for(let i=0;i<maxTextures;i++){src+='\\nelse ';if(i<maxTextures-1){src+=`if(textureId == ${i}.0)`;}src+='\\n{';src+=`\\n\\tcolor = texture2D(uSamplers[${i}], textureCoord * uSamplerSize[${i}]);`;src+='\\n}';}src+='\\n';src+='\\n';return src;}/**\r\n * @internal\r\n * @ignore\r\n * @param shader\r\n * @param maxTextures\r\n */function fillSamplers(shader,maxTextures){const sampleValues=[];for(let i=0;i<maxTextures;i++){sampleValues[i]=i;}shader.uniforms.uSamplers=sampleValues;const samplerSize=[];for(let i=0;i<maxTextures;i++){// These are overwritten by TileRenderer when textures actually bound.\nsamplerSize.push(1.0/2048);samplerSize.push(1.0/2048);}shader.uniforms.uSamplerSize=samplerSize;}/**\r\n * @internal\r\n * @ignore\r\n * @param maxTextures\r\n * @param fragmentSrc\r\n * @returns\r\n */function generateFragmentSrc(maxTextures,fragmentSrc){return fragmentSrc.replace(/%count%/gi,`${maxTextures}`).replace(/%forloop%/gi,generateSampleSrc(maxTextures));}// eslint-disable-next-line @typescript-eslint/triple-slash-reference, spaced-comment\nconst tilemapVertexTemplateSrc=`#version 100\nprecision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aFrame;\nattribute vec2 aAnim;\nattribute float aAnimDivisor;\nattribute float aTextureId;\nattribute float aAlpha;\n\nuniform mat3 projTransMatrix;\nuniform vec2 animationFrame;\n\nvarying vec2 vTextureCoord;\nvarying float vTextureId;\nvarying vec4 vFrame;\nvarying float vAlpha;\n\nvoid main(void)\n{\n   gl_Position = vec4((projTransMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vec2 animCount = floor((aAnim + 0.5) / 2048.0);\n   vec2 animFrameOffset = aAnim - animCount * 2048.0;\n   vec2 currentFrame = floor(animationFrame / aAnimDivisor);\n   vec2 animOffset = animFrameOffset * floor(mod(currentFrame + 0.5, animCount));\n\n   vTextureCoord = aTextureCoord + animOffset;\n   vFrame = aFrame + vec4(animOffset, animOffset);\n   vTextureId = aTextureId;\n   vAlpha = aAlpha;\n}\n`;const tilemapFragmentTemplateSrc=`#version 100\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\nvarying vec2 vTextureCoord;\nvarying vec4 vFrame;\nvarying float vTextureId;\nvarying float vAlpha;\nuniform vec4 shadowColor;\nuniform sampler2D uSamplers[%count%];\nuniform vec2 uSamplerSize[%count%];\n\nvoid main(void)\n{\n   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\n   float textureId = floor(vTextureId + 0.5);\n\n   vec4 color;\n   %forloop%\n   gl_FragColor = color * vAlpha;\n}\n`;// For some reason ESLint goes mad with indendation in this file ^&^\n/* eslint-disable no-mixed-spaces-and-tabs, indent */class TilemapShader extends Shader{__init(){this.maxTextures=0;}constructor(maxTextures){super(new Program(tilemapVertexTemplateSrc,generateFragmentSrc(maxTextures,tilemapFragmentTemplateSrc)),{animationFrame:new Float32Array(2),uSamplers:[],uSamplerSize:[],projTransMatrix:new Matrix()});TilemapShader.prototype.__init.call(this);this.maxTextures=maxTextures;fillSamplers(this,this.maxTextures);}}class TilemapGeometry extends Geometry{__init2(){this.vertSize=13;}__init3(){this.vertPerQuad=4;}__init4(){this.stride=this.vertSize*4;}__init5(){this.lastTimeAccess=0;}constructor(){super();TilemapGeometry.prototype.__init2.call(this);TilemapGeometry.prototype.__init3.call(this);TilemapGeometry.prototype.__init4.call(this);TilemapGeometry.prototype.__init5.call(this);const buf=this.buf=new Buffer(new Float32Array(2),true,false);this.addAttribute('aVertexPosition',buf,0,false,0,this.stride,0).addAttribute('aTextureCoord',buf,0,false,0,this.stride,2*4).addAttribute('aFrame',buf,0,false,0,this.stride,4*4).addAttribute('aAnim',buf,0,false,0,this.stride,8*4).addAttribute('aTextureId',buf,0,false,0,this.stride,10*4).addAttribute('aAnimDivisor',buf,0,false,0,this.stride,11*4).addAttribute('aAlpha',buf,0,false,0,this.stride,12*4);}}// For some reason ESLint goes mad with indendation in this file ^&^\n/* eslint-disable no-mixed-spaces-and-tabs, indent */ /**\r\n * Rendering helper pipeline for tilemaps. This plugin is registered automatically.\r\n */class TileRenderer extends ObjectRenderer{/** The managing renderer */ /** The tile animation frame */__init(){this.tileAnim=[0,0];}__init2(){this.ibLen=0;}// index buffer length\n/** The index buffer for the tilemaps to share. */__init3(){this.indexBuffer=null;}/** The shader used to render tilemaps. */ /**\r\n\t * {@link TextileResource} instances used to upload textures batched in tiled groups. This is\r\n\t * used only if {@link settings.TEXTURES_PER_TILEMAP} is greater than 1.\r\n\t */__init4(){this.textiles=[];}/** @param renderer - The managing renderer */constructor(renderer){super(renderer);TileRenderer.prototype.__init.call(this);TileRenderer.prototype.__init2.call(this);TileRenderer.prototype.__init3.call(this);TileRenderer.prototype.__init4.call(this);this.shader=new TilemapShader(settings.TEXTURES_PER_TILEMAP);this.indexBuffer=new Buffer(undefined,true,true);this.checkIndexBuffer(2000);this.makeTextiles();}/**\r\n\t * Binds the tile textures to the renderer, and updates the tilemap shader's `uSamplerSize` uniform.\r\n\t *\r\n\t * If {@link settings.TEXTILE_UNITS}\r\n\t *\r\n\t * @param renderer - The renderer to which the textures are to be bound.\r\n\t * @param textures - The tile textures being bound.\r\n\t */bindTileTextures(renderer,textures){const len=textures.length;const shader=this.shader;const maxTextures=settings.TEXTURES_PER_TILEMAP;const samplerSize=shader.uniforms.uSamplerSize;if(len>settings.TEXTILE_UNITS*maxTextures){// TODO: Show error message instead of silently failing!\nreturn;}if(settings.TEXTILE_UNITS<=1){// Bind each texture directly & update samplerSize.\nfor(let i=0;i<textures.length;i++){const texture=textures[i];if(!texture||!texture.valid){return;}renderer.texture.bind(textures[i],i);samplerSize[i*2]=1.0/textures[i].realWidth;samplerSize[i*2+1]=1.0/textures[i].realHeight;}}else{// Ensure we have enough textiles, in case settings.TEXTILE_UNITS was modified.\nthis.makeTextiles();const usedTextiles=Math.ceil(len/settings.TEXTILE_UNITS);// First ensure each textile has all tiles point to the right textures.\nfor(let i=0;i<len;i++){const texture=textures[i];if(texture&&texture.valid){const resourceIndex=Math.floor(i/settings.TEXTILE_UNITS);const tileIndex=i%settings.TEXTILE_UNITS;this.textiles[resourceIndex].tile(tileIndex,texture);}}// Then bind the textiles + update samplerSize.\nfor(let i=0;i<usedTextiles;i++){renderer.texture.bind(this.textiles[i].baseTexture,i);samplerSize[i*2]=1.0/this.textiles[i].width;samplerSize[i*2+1]=1.0/this.textiles[i].baseTexture.height;}}shader.uniforms.uSamplerSize=samplerSize;}start(){// sorry, nothing\n}/**\r\n\t * @internal\r\n\t * @ignore\r\n\t */createVb(){const geom=new TilemapGeometry();geom.addIndex(this.indexBuffer);geom.lastTimeAccess=Date.now();return geom;}/** @return The {@link TilemapShader} shader that this rendering pipeline is using. */getShader(){return this.shader;}destroy(){super.destroy();// this.rectShader.destroy();\nthis.shader=null;}checkIndexBuffer(size){let _vb=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;const totalIndices=size*6;if(totalIndices<=this.ibLen){return;}this.ibLen=totalIndices;this.indexBuffer.update(createIndicesForQuads(size,settings.use32bitIndex?new Uint32Array(size*6):undefined));// \tTODO: create new index buffer instead?\n// if (vb) {\n// \tconst curIndex = vb.getIndex();\n// \tif (curIndex !== this.indexBuffer && (curIndex.data as any).length < totalIndices) {\n// \t\tthis.swapIndex(vb, this.indexBuffer);\n// \t}\n// }\n}/** Makes textile resources and initializes {@link TileRenderer.textiles}. */makeTextiles(){if(settings.TEXTILE_UNITS<=1){return;}for(let i=0;i<settings.TEXTILE_UNITS;i++){if(this.textiles[i])continue;const resource=new TextileResource();const baseTex=new BaseTexture(resource);baseTex.scaleMode=settings.TEXTILE_SCALE_MODE;baseTex.wrapMode=WRAP_MODES.CLAMP;this.textiles[i]=resource;}}}// eslint-disable-next-line camelcase\nconst pixi_tilemap={CanvasTileRenderer,CompositeRectTileLayer:CompositeTilemap,CompositeTilemap,Constant,TextileResource,MultiTextureResource:TextileResource,RectTileLayer:Tilemap,Tilemap,TilemapShader,TilemapGeometry,RectTileShader:TilemapShader,RectTileGeom:TilemapGeometry,TileRenderer};Renderer.registerPlugin('tilemap',TileRenderer);export{CanvasTileRenderer,CompositeTilemap as CompositeRectTileLayer,CompositeTilemap,Constant,POINT_STRUCT_SIZE,Tilemap as RectTileLayer,TextileResource,TileRenderer,Tilemap,TilemapGeometry,TilemapShader,fillSamplers,generateFragmentSrc,pixi_tilemap,settings};","map":null,"metadata":{},"sourceType":"module"}