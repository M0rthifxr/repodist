{"ast":null,"code":"import{UnseenItemsEvent,UnseenResetCategoryComposer,UnseenResetItemsComposer}from'@nitrots/nitro-renderer';import{useCallback,useMemo,useState}from'react';import{useBetween}from'use-between';import{UseMessageEventHook}from'..';import{SendMessageComposer}from'../../api';const sendResetCategoryMessage=category=>SendMessageComposer(new UnseenResetCategoryComposer(category));const sendResetItemsMessage=(category,itemIds)=>SendMessageComposer(new UnseenResetItemsComposer(category,...itemIds));const useInventoryUnseenTrackerState=()=>{const[unseenItems,setUnseenItems]=useState(new Map());const getCount=useCallback(category=>{var _unseenItems$get;return((_unseenItems$get=unseenItems.get(category))===null||_unseenItems$get===void 0?void 0:_unseenItems$get.length)||0;},[unseenItems]);const getFullCount=useMemo(()=>{let count=0;for(const key of unseenItems.keys())count+=getCount(key);return count;},[unseenItems,getCount]);const resetCategory=useCallback(category=>{let didReset=true;setUnseenItems(prevValue=>{if(!prevValue.has(category)){didReset=false;return prevValue;}const newValue=new Map(prevValue);newValue.delete(category);sendResetCategoryMessage(category);return newValue;});return didReset;},[]);const resetItems=useCallback((category,itemIds)=>{let didReset=true;setUnseenItems(prevValue=>{if(!prevValue.has(category)){didReset=false;return prevValue;}const newValue=new Map(prevValue);const existing=newValue.get(category);if(existing)for(const itemId of itemIds)existing.splice(existing.indexOf(itemId),1);sendResetItemsMessage(category,itemIds);return newValue;});return didReset;},[]);const isUnseen=useCallback((category,itemId)=>{if(!unseenItems.has(category))return false;const items=unseenItems.get(category);return items.indexOf(itemId)>=0;},[unseenItems]);const removeUnseen=useCallback((category,itemId)=>{setUnseenItems(prevValue=>{if(!prevValue.has(category))return prevValue;const newValue=new Map(prevValue);const items=newValue.get(category);const index=items.indexOf(itemId);if(index>=0)items.splice(index,1);return newValue;});},[]);const onUnseenItemsEvent=useCallback(event=>{const parser=event.getParser();setUnseenItems(prevValue=>{const newValue=new Map(prevValue);for(const category of parser.categories){let existing=newValue.get(category);if(!existing){existing=[];newValue.set(category,existing);}const itemIds=parser.getItemsByCategory(category);for(const itemId of itemIds)existing.indexOf(itemId)===-1&&existing.push(itemId);}return newValue;});},[]);UseMessageEventHook(UnseenItemsEvent,onUnseenItemsEvent);return{getCount,getFullCount,resetCategory,resetItems,isUnseen,removeUnseen};};export const useInventoryUnseenTracker=()=>useBetween(useInventoryUnseenTrackerState);","map":null,"metadata":{},"sourceType":"module"}