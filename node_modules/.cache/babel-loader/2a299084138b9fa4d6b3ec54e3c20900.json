{"ast":null,"code":"import{NitroManager}from'../../core/common/NitroManager';import{BadgePointLimitsEvent}from'../communication/messages/incoming/inventory/badges/BadgePointLimitsEvent';import{Nitro}from'../Nitro';import{BadgeBaseAndLevel}from'./BadgeBaseAndLevel';import{NitroLocalizationEvent}from'./NitroLocalizationEvent';export class NitroLocalizationManager extends NitroManager{constructor(communication){super();this._communication=void 0;this._definitions=void 0;this._parameters=void 0;this._badgePointLimits=void 0;this._romanNumerals=void 0;this._pendingUrls=void 0;this._communication=communication;this._definitions=new Map();this._parameters=new Map();this._badgePointLimits=new Map();this._romanNumerals=['I','II','III','IV','V','VI','VII','VIII','IX','X','XI','XII','XIII','XIV','XV','XVI','XVII','XVIII','XIX','XX','XXI','XXII','XXIII','XXIV','XXV','XXVI','XXVII','XXVIII','XXIX','XXX'];this._pendingUrls=[];}onInit(){this._communication.registerMessageEvent(new BadgePointLimitsEvent(this.onBadgePointLimitsEvent.bind(this)));let urls=Nitro.instance.getConfiguration('external.texts.url');if(!Array.isArray(urls)){urls=[Nitro.instance.getConfiguration('external.texts.url')];}for(let i=0;i<urls.length;i++)urls[i]=Nitro.instance.core.configuration.interpolate(urls[i]);this._pendingUrls=urls;this.loadNextLocalization();}loadNextLocalization(){if(!this._pendingUrls.length){this.events&&this.events.dispatchEvent(new NitroLocalizationEvent(NitroLocalizationEvent.LOADED));return;}this.loadLocalizationFromURL(this._pendingUrls[0]);}loadLocalizationFromURL(url){fetch(url).then(response=>response.json()).then(data=>this.onLocalizationLoaded(data,url)).catch(err=>this.onLocalizationFailed(err));}onLocalizationLoaded(data,url){if(!data)return;if(!this.parseLocalization(data))throw new Error(`Invalid json data for file ${url}`);const index=this._pendingUrls.indexOf(url);if(index>=0)this._pendingUrls.splice(index,1);this.loadNextLocalization();}onLocalizationFailed(error){this.events&&this.events.dispatchEvent(new NitroLocalizationEvent(NitroLocalizationEvent.FAILED));}parseLocalization(data){if(!data)return false;for(const key in data)this._definitions.set(key,data[key]);return true;}onBadgePointLimitsEvent(event){const parser=event.getParser();for(const data of parser.data)this.setBadgePointLimit(data.badgeId,data.limit);}getBadgePointLimit(badge){return this._badgePointLimits.get(badge)||-1;}setBadgePointLimit(badge,point){this._badgePointLimits.set(badge,point);}getRomanNumeral(number){return this._romanNumerals[Math.max(0,number-1)];}getPreviousLevelBadgeId(badgeName){const badge=new BadgeBaseAndLevel(badgeName);badge.level--;return badge.getBadgeId;}hasValue(key){return this._definitions.has(key);}getValue(key){let doParams=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(!key||!key.length)return null;const keys=key.match(/\\$\\{.[^}]*\\}/g);if(keys&&keys.length){for(const splitKey of keys)key=key.replace(splitKey,this.getValue(splitKey.slice(2,-1),doParams));}let value=this._definitions.get(key)||null;if(!value){value=Nitro.instance.core.configuration.definitions.get(key);if(value)return value;}if(value&&doParams){const parameters=this._parameters.get(key);if(parameters){for(const[parameter,replacement]of parameters){value=value.replace('%'+parameter+'%',replacement);}}}return value||key;}getValueWithParameter(key,parameter,replacement){const value=this.getValue(key,false);const replacedValue=value.replace('%'+parameter+'%',replacement);if(value.startsWith('%{')){// This adds support for multi-optioned texts like\n// catalog.vip.item.header.months=%{NUM_MONTHS|0 months|1 month|%% months}\n// It only checks for this multi-optioned thext if the value of the key starts with %{\n// If it does, it will create a RegEx with the provided parameter, eg. NUM_DAYS or NUM_MONTS\n// Then, based on the provided replacement it searches for the resultgroup based on the replacement.\n// If the replacement is not either 0, 1 - it will be assumed it will be plural. (eg. Months)\nconst regex=new RegExp('%{'+parameter.toUpperCase()+'\\\\|([^|]*)\\\\|([^|]*)\\\\|([^|]*)}');const result=value.match(regex);if(!result)return replacedValue;let indexKey=-1;const replacementAsNumber=Number.parseInt(replacement);let replace=false;switch(replacementAsNumber){case 0:indexKey=1;break;case 1:indexKey=2;break;default:case 2:indexKey=3;replace=true;break;}if(indexKey==-1||typeof result[indexKey]=='undefined'){return replacedValue;}const valueFromResults=result[indexKey];if(valueFromResults){return valueFromResults.replace('%%',replacement);}}return replacedValue;}getValueWithParameters(key,parameters,replacements){let value=this.getValue(key,false);if(parameters){for(let i=0;i<parameters.length;i++){const parameter=parameters[i];const replacement=replacements[i];if(replacement===undefined)continue;value=value.replace('%'+parameter+'%',replacement);if(value.startsWith('%{')){const regex=new RegExp('%{'+parameter.toUpperCase()+'\\\\|([^|]*)\\\\|([^|]*)\\\\|([^|]*)}');const result=value.match(regex);if(!result)continue;const replacementAsNumber=parseInt(replacement);let indexKey=-1;let replace=false;switch(replacementAsNumber){case 0:indexKey=1;break;case 1:indexKey=2;break;case 2:default:indexKey=3;replace=true;break;}if(indexKey===-1||typeof result[indexKey]==='undefined')continue;const valueFromResults=result[indexKey];if(valueFromResults){value=valueFromResults.replace('%%',replacement);}}}}return value;}setValue(key,value){this._definitions.set(key,value);}registerParameter(key,parameter,value){if(!key||key.length===0||!parameter||parameter.length===0)return;let existing=this._parameters.get(key);if(!existing){existing=new Map();this._parameters.set(key,existing);}existing.set(parameter,value);}getBadgeName(key){const badge=new BadgeBaseAndLevel(key);const keys=['badge_name_'+key,'badge_name_'+badge.base];let name=this._Str_2103(this.getExistingKey(keys));name=name.replace('%roman%',this.getRomanNumeral(badge.level));return name;}getBadgeDesc(key){const badge=new BadgeBaseAndLevel(key);const keys=['badge_desc_'+key,'badge_desc_'+badge.base];let desc=this._Str_2103(this.getExistingKey(keys));const limit=this.getBadgePointLimit(key);if(limit>-1)desc=desc.replace('%limit%',limit.toString());desc=desc.replace('%roman%',this.getRomanNumeral(badge.level));return desc;}getExistingKey(keys){for(const entry of keys){const item=this.getValue(entry);if(item!=entry)return item;}return'';}_Str_2103(k){return k.replace('${','$').replace('{','$').replace('}','$');}}","map":null,"metadata":{},"sourceType":"module"}