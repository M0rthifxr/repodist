{"ast":null,"code":"import{Nitro}from'../../nitro/Nitro';import{Disposable}from'../common/disposable/Disposable';import{NitroLogger}from'../common/logger/NitroLogger';export class EventDispatcher extends Disposable{constructor(){super();this._logger=void 0;this._listeners=void 0;this._logger=new NitroLogger(this.constructor.name);this._listeners=new Map();}onDispose(){this.removeAllListeners();super.onDispose();}addEventListener(type,callback){if(!type||!callback)return;const existing=this._listeners.get(type);if(!existing){this._listeners.set(type,[callback]);return;}existing.push(callback);}removeEventListener(type,callback){if(!type||!callback)return;const existing=this._listeners.get(type);if(!existing||!existing.length)return;for(const[i,cb]of existing.entries()){if(!cb||cb!==callback)continue;existing.splice(i,1);if(!existing.length)this._listeners.delete(type);return;}}dispatchEvent(event){if(!event)return false;if(Nitro.instance.getConfiguration('system.dispatcher.log'))this._logger.log(`DISPATCHED: ${event.type}`);this.processEvent(event);return true;}processEvent(event){const existing=this._listeners.get(event.type);if(!existing||!existing.length)return;const callbacks=[];for(const callback of existing){if(!callback)continue;callbacks.push(callback);}while(callbacks.length){const callback=callbacks.shift();try{callback(event);}catch(err){this._logger.error(err.stack);return;}}}removeAllListeners(){this._listeners.clear();}}","map":null,"metadata":{},"sourceType":"module"}